// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package blockfile provides methods for reading packets from blockfiles
// generated by stenotype.
package blockfile

import (
	"errors"
	"fmt"
	"io"
	"os"
	"time"
	"unsafe"

	"code.google.com/p/gopacket"
	"github.com/google/stenographer/base"
	"github.com/google/stenographer/indexfile"
	"github.com/google/stenographer/query"
)

// #include <linux/if_packet.h>
import "C"

var v = base.V // Verbose logging.

// BlockFile provides an interface to a single stenotype file on disk and its
// associated index.
type BlockFile struct {
	name string
	f    *os.File
	i    *indexfile.IndexFile
}

// NewBlockFile opens up a named block file (and its index), returning a handle
// which can be used to look up packets.
func NewBlockFile(filename string) (*BlockFile, error) {
	v(1, "opening blockfile %q", filename)
	f, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("could not open %q: %v", filename, err)
	}
	i, err := indexfile.NewIndexFile(indexfile.IndexPathFromPath(filename))
	if err != nil {
		f.Close()
		return nil, fmt.Errorf("could not open index for %q: %v", filename, err)
	}
	return &BlockFile{
		f:    f,
		i:    i,
		name: filename,
	}, nil
}

// StillAtOriginalPath returns true if the file is still able to be accessed at
// its original file path.  If not, we assumes that this file has been
// removed, and it can clean up the blockfile so it doesn't stay around on the
// filesystem as an unlinked file.
func (b *BlockFile) StillAtOriginalPath() bool {
	_, err := os.Stat(b.name)
	return err == nil
}

// Name returns the name of the file underlying this blockfile.
func (b *BlockFile) Name() string {
	return b.name
}

// readPacket reads a single packet from the file at the given position.
// It updates the passed in CaptureInfo with information on the packet.
func (b *BlockFile) readPacket(pos int64, ci *gopacket.CaptureInfo) ([]byte, error) {
	// 28 bytes actually isn't the entire packet header, but it's all the fields
	// that we care about.
	var dataBuf [28]byte
	_, err := b.f.ReadAt(dataBuf[:], pos)
	if err != nil {
		return nil, err
	}
	pkt := (*C.struct_tpacket3_hdr)(unsafe.Pointer(&dataBuf[0]))
	*ci = gopacket.CaptureInfo{
		Timestamp:     time.Unix(int64(pkt.tp_sec), int64(pkt.tp_nsec)),
		Length:        int(pkt.tp_len),
		CaptureLength: int(pkt.tp_snaplen),
	}
	out := make([]byte, ci.CaptureLength)
	pos += int64(pkt.tp_mac)
	_, err = b.f.ReadAt(out, pos)
	return out, err
}

// Close() cleans up this blockfile.
func (b *BlockFile) Close() (err error) {
	if e := b.i.Close(); e != nil {
		err = e
	}
	if e := b.f.Close(); e != nil {
		err = e
	}
	return
}

// Iter provides a simple interface for iterating over all packets in a
// blockfile.  It follows the normal Go convention:
//   iter := myBlockfile.AllPackets()
//   for iter.Next() {
//     ... handle iter.Packet()
//   }
//   if err := iter.Err(); err != nil { ... handle error ... }
type Iter interface {
	// Packet returns the current packet pointed to by the iterator.  This call
	// must be preceded by a Next() call that returns true.
	Packet() *base.Packet
	// Err returns any error that occurred during iteration.  It should be called
	// after the first Next() call to return false.
	Err() error
	// Next advances the iterator to the first or next packet, returning false
	// when there are no more packets to process.
	Next() bool
}

// allPacketsIter implements Iter.
type allPacketsIter struct {
	*BlockFile
	blockData        [1 << 20]byte
	block            *C.struct_tpacket_hdr_v1
	pkt              *C.struct_tpacket3_hdr
	blockPacketsRead int
	blockOffset      int64
	packetOffset     int // offset of packet in block
	err              error
	done             bool
}

func (a *allPacketsIter) Next() bool {
	if a.err != nil || a.done {
		return false
	}
	for a.block == nil || a.blockPacketsRead == int(a.block.num_pkts) {
		_, err := a.f.ReadAt(a.blockData[:], a.blockOffset)
		if err == io.EOF {
			a.done = true
			return false
		} else if err != nil {
			a.err = fmt.Errorf("could not read block at %v: %v", a.blockOffset, err)
			return false
		}
		baseHdr := (*C.struct_tpacket_block_desc)(unsafe.Pointer(&a.blockData[0]))
		a.block = (*C.struct_tpacket_hdr_v1)(unsafe.Pointer(&baseHdr.hdr[0]))
		a.blockOffset += 1 << 20
		a.blockPacketsRead = 0
		a.pkt = nil
	}
	a.blockPacketsRead++
	if a.pkt == nil {
		a.packetOffset = int(a.block.offset_to_first_pkt)
	} else if a.pkt.tp_next_offset != 0 {
		a.packetOffset += int(a.pkt.tp_next_offset)
	} else {
		a.err = errors.New("block format currently not supported")
		return false
	}
	a.pkt = (*C.struct_tpacket3_hdr)(unsafe.Pointer(&a.blockData[a.packetOffset]))
	return true
}

func (a *allPacketsIter) Packet() *base.Packet {
	start := a.packetOffset + int(a.pkt.tp_mac)
	buf := a.blockData[start : start+int(a.pkt.tp_snaplen)]
	p := &base.Packet{Data: buf}
	p.CaptureInfo.Timestamp = time.Unix(int64(a.pkt.tp_sec), int64(a.pkt.tp_nsec))
	p.CaptureInfo.Length = int(a.pkt.tp_len)
	p.CaptureInfo.CaptureLength = int(a.pkt.tp_snaplen)
	return p
}

func (a *allPacketsIter) Err() error {
	return a.err
}

func (b *BlockFile) AllPackets() Iter {
	return &allPacketsIter{BlockFile: b}
}

func (b *BlockFile) Lookup(q query.Query) base.PacketChan {
	c := base.NewPacketChan(100)
	go func() {
		var ci gopacket.CaptureInfo
		positions, err := q.LookupIn(b.i)
		if err != nil {
			c.Close(fmt.Errorf("index lookup failure: %v", err))
			return
		}
		if positions.IsAllPositions() {
			v(2, "blockfile %q reading all packets", b.name)
			iter := &allPacketsIter{BlockFile: b}
			for iter.Next() {
				c.Send(iter.Packet())
			}
			if iter.Err() != nil {
				c.Close(fmt.Errorf("error reading all packets from %q: %v", b.name, iter.Err()))
				return
			}
		} else {
			v(2, "blockfile %q reading %v packets", b.name, len(positions))
			for _, pos := range positions {
				buffer, err := b.readPacket(pos, &ci)
				if err != nil {
					c.Close(fmt.Errorf("error reading packets from %q @ %v: %v", b.name, pos, err))
					return
				}
				c.Send(&base.Packet{
					Data:        buffer,
					CaptureInfo: ci,
				})
			}
		}
		c.Close(nil)
	}()
	return c
}

func (b *BlockFile) DumpIndex(out io.Writer) {
	b.i.Dump(out)
}
