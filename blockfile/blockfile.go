// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package blockfile provides methods for reading packets from blockfiles
// generated by stenotype.
package blockfile

import (
	"fmt"
	"io"
	"os"
	"time"
	"unsafe"

	"code.google.com/p/gopacket"
	"github.com/google/stenographer/base"
	"github.com/google/stenographer/indexfile"
)

// #include <linux/if_packet.h>
import "C"

var v = base.V // Verbose logging.

// BlockFile provides an interface to a single stenotype file on disk and its
// associated index.
type BlockFile struct {
	name string
	f    *os.File
	i    *indexfile.IndexFile
}

// NewBlockFile opens up a named block file (and its index), returning a handle
// which can be used to look up packets.
func NewBlockFile(filename string) (*BlockFile, error) {
	v(1, "opening blockfile %q", filename)
	f, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("could not open %q: %v", filename, err)
	}
	i, err := indexfile.NewIndexFile(indexfile.IndexPathFromPath(filename))
	if err != nil {
		f.Close()
		return nil, fmt.Errorf("could not open index for %q: %v", filename, err)
	}
	return &BlockFile{
		f:    f,
		i:    i,
		name: filename,
	}, nil
}

// StillAtOriginalPath returns true if the file is still able to be accessed at
// its original file path.  If not, we assumes that this file has been
// removed, and it can clean up the blockfile so it doesn't stay around on the
// filesystem as an unlinked file.
func (b *BlockFile) StillAtOriginalPath() bool {
	_, err := os.Stat(b.name)
	return err == nil
}

// Name returns the name of the file underlying this blockfile.
func (b *BlockFile) Name() string {
	return b.name
}

// readPacket reads a single packet from the file at the given position.
// It updates the passed in CaptureInfo with information on the packet.
func (b *BlockFile) readPacket(pos int64, ci *gopacket.CaptureInfo) ([]byte, error) {
	var dataBuf [28]byte
	// 28 bytes actually isn't the entire packet header, but it's all the fields
	// that we care about.
	_, err := b.f.ReadAt(dataBuf[:], pos)
	if err != nil {
		return nil, err
	}
	pkt := (*C.struct_tpacket3_hdr)(unsafe.Pointer(&dataBuf[0]))
	*ci = gopacket.CaptureInfo{
		Timestamp:     time.Unix(int64(pkt.tp_sec), int64(pkt.tp_nsec)),
		Length:        int(pkt.tp_len),
		CaptureLength: int(pkt.tp_snaplen),
	}
	out := make([]byte, ci.CaptureLength)
	pos += int64(pkt.tp_mac)
	_, err = b.f.ReadAt(out, pos)
	return out, err
}

// Close() cleans up this blockfile.
func (b *BlockFile) Close() (err error) {
	if e := b.i.Close(); e != nil {
		err = e
	}
	if e := b.f.Close(); e != nil {
		err = e
	}
	return
}

func (b *BlockFile) Lookup(in string) base.PacketChan {
	c := base.NewPacketChan(100)
	go func() {
		var ci gopacket.CaptureInfo
		positions, err := b.i.Lookup(in)
		if err != nil {
			c.Close(fmt.Errorf("index lookup failure: %v", err))
			return
		}
		v(2, "blockfile %q reading %v packets", b.name, len(positions))
		for _, pos := range positions {
			buffer, err := b.readPacket(pos, &ci)
			if err != nil {
				c.Close(fmt.Errorf("error reading packets from %q @ %v: %v", b.name, pos, err))
				return
			}
			c.Send(&base.Packet{
				Data:        buffer,
				CaptureInfo: ci,
			})
		}
		c.Close(nil)
	}()
	return c
}

func (b *BlockFile) DumpIndex(out io.Writer) {
	b.i.Dump(out)
}
